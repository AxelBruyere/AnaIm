function [u,v] = motion_hs(image1,image2,lambda,mean_filter,threshold]
%Parametres d'entree :
%   image1 -> adresse de la premiere image
%   image2 -> adresse de la seconde image
%   lambda
%   mean-filter -> filtre moyenneur => '4-voisinage' ou '9-voisinage'
%   threshold -> critere d'arret

%Parametres de sortie : 
%   -(u,v) -> le flux optique
%   -it -> nombre d'iterations faites

%RÃ©cupÃ©ration des images
I1 = im2double(imread('MiniCooper/i0001.png'));
I2 = im2double(imread('MiniCooper/i0002.png'));
[H,W] = size(I1);
%Calcul des gradients
It = (I2 - I1);
[Ix,Iy] = imgradientxy(I1);

%Initialisation de (u,v) et (u\,v\)
u = zeros(H,W);
v = zeros(H,W);
u_barre = u;
v_barre = v;

%Creation du filtre moyenneur
switch mean_filter
    case '4-voisinage'
        filtre = 1/4*[0,1,0;
                      1,0,1;
                      0,1,0];
    case '9-voisinage'
        filtre = 1/9*ones(3,3);
        filtre(2,2) = 0;
end

it = 0;%Compteur d'iterations

%Cal
while (abs(mean_ctrl_u - mean_u) > seuil || abs(mean_ctrl_v - mean_v) > seuil )
    it = it + 1;
        mean_ctrl_u = mean_u;
        mean_ctrl_v = mean_v;
        u_barre = imfilter(u,filtre);
        v_barre = imfilter(v,filtre);

        u = u_barre - Ix.*(Ix.*u_barre + Iy.*v_barre + It)./...
            (lambda^2+Ix.^2+Iy.^2);
        v = v_barre - Iy.*(Ix.*u_barre + Iy.*v_barre + It)./...
            (lambda^2+Ix.^2+Iy.^2);
        
        mean_u = mean(mean(u));
        mean_v = mean(mean(v));        
end